@page "/snakegame"
@layout ContentLayout
@inject IJSRuntime jsRuntime
@inject IConfiguration appConfig
@inject Blazored.LocalStorage.ILocalStorageService localStorage
@using Blazor.Extensions
@using Blazor.Extensions.Canvas.Canvas2D
@using Microsoft.Extensions.Configuration
@using System.Timers


<div id="game-controls">
    <h3 id="score-display">Score:@currentScores.current  Time:@timeDisplay</h3>
    <div>
        <button class="soft-shadow game-button @((turnCount > 0 && turnManager.Enabled) ? "dark-bg" : "")" @onclick=startGame>start</button>
        <button class="soft-shadow game-button" @onclick=setupNewGame>reset</button>
    </div>
</div>
<div id="snake-container" class="soft-shadow" tabindex="0" @onkeydown=@((e) => playerInputHandler(e.Key))>
    @if (turnCount > 0 && !turnManager.Enabled)
    {
        <div id="game-over" class="dark-bg soft-shadow">
            <h2>Game Over</h2>
            <h4>Score: @currentScores.current</h4>
            <h4>Best: @currentScores.high</h4>
        </div>
    }
    <BECanvas Width="@windowSize" Height="@windowSize" @ref="_canvasReference" />
</div>
@if(isMobile)
{
    <TouchDPad inputCallback=playerInputHandler></TouchDPad>
}

@code {
    protected BECanvasComponent? _canvasReference { get; set; }
    private Canvas2DContext? _canvas { get; set; }
    private int windowSize { get; set; }
    private bool isMobile { get; set; }
    private (int r, int c) configLimits { get; set; }

    private SnakeBoard? gameBoard { get; set; }
    private Timer turnManager { get; set; }
    private DateTime startTime { get; set; }
    private string timeDisplay { get; set; }

    private (long high, long current) currentScores;
    private bool canMove { get; set; }
    private int turnCount { get; set; }

    protected override async Task OnInitializedAsync()
    {
        await setCanvasSize();
        readConfigValues();
        isMobile = await jsRuntime.InvokeAsync<bool>("isMobile");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _canvas = await _canvasReference.CreateCanvas2DAsync();
            await setupNewGame();
            var previousHighScore = await localStorage.GetItemAsync<int>("highScore");
            if (previousHighScore > currentScores.high)
                currentScores.high = previousHighScore;
        }
    }

    private void readConfigValues()
    {
        configLimits = (int.Parse(appConfig["snake-board-width"]),
                        int.Parse(appConfig["snake-board-height"]));
    }

    private async Task setCanvasSize()
    {
        double windowWidth = await jsRuntime.InvokeAsync<long>("getWindowWidth");
        double windowHeight = await jsRuntime.InvokeAsync<long>("getWindowHeight");

        windowWidth = (windowWidth * 0.08) * 10;
        windowHeight = (windowHeight * 0.08) * 10;

        if (windowHeight >= windowWidth)
            windowSize = (int)(windowWidth - (windowWidth % configLimits.c));
        else
            windowSize = (int)(windowHeight - (windowHeight % configLimits.r));

        StateHasChanged();
    }

    private void playerInputHandler(string direction)
    {
        if (turnManager.Enabled && canMove)
        {
            gameBoard.snake.parseMoveCommand(direction);
        }
        canMove = false;
    }
    
    private void setupTimer()
    {
        if (turnManager != null && turnManager.Enabled)
        {
            turnManager.Dispose();
        }
        turnManager = new Timer(400) { AutoReset = true, Enabled = false };
        turnManager.Elapsed += runTurn;
    }

    private async Task startGame()
    {
        await jsRuntime.InvokeVoidAsync("setFocus");
        if (turnManager.Enabled)
            return;
        else
        {
            if (currentScores.current > 0)
                await setupNewGame();
            gameBoard.makeFood();
            turnManager.Enabled = true;
            startTime = DateTime.Now;
        }
    }

    private async Task setupNewGame()
    {
        turnCount = 0;
        currentScores.current = 0;
        setupTimer();
        await setCanvasSize();
        await _canvas.ClearRectAsync(0, 0, _canvasReference.Width, _canvasReference.Height);
        gameBoard = new SnakeBoard(
            (int)_canvasReference.Width, 
            (int)_canvasReference.Height, 
            configLimits, _canvas);
    }

    private void increaseSpeed()
    {
        if (turnManager.Enabled)
            turnManager.Interval = 1400 / gameBoard.snake.size;
    }

    private async void runTurn(Object? src, ElapsedEventArgs e)
    {
        timeDisplay = (e.SignalTime - startTime).ToString("mm\\:ss");
        turnCount++;
        currentScores.current += (int)(Math.Ceiling(turnCount / 10.0)) * gameBoard.snake.size;
        gameBoard.snake.setNextSnakePosition();
        await gameBoard.drawGameState();
        if (!gameBoard.checkSpot(new Action(increaseSpeed)))
        {
            turnManager.Enabled = false;
            if (currentScores.current > currentScores.high)
            {
                currentScores.high = currentScores.current;
            }
        }
        canMove = true;
        StateHasChanged();
    }
}
