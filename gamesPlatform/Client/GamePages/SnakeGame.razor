@page "/snakegame"
@inject IJSRuntime jsRuntime
@inject IScoreService scoreService
@implements IDisposable
@inherits GamePage<SnakeBoard>
@layout MainLayout
@using cmArcade.Client.GenericPages

<main id="main-content">
    <div id="game-controls">
        <div id="score-display">
            <span> Score:@currentScore?.scoreValue </span>
            @if (highScore?.scoreValue > 0)
            {
                <span> Best: @highScore?.scoreValue  </span>
            }
            <span> Time:@currentScore?.runLength.ToString("mm\\:ss") </span>
        </div>
        <div>
            <button type="button" class="soft-shadow game-button @((turnCount > 0 && gameControl.Enabled) ? "dark-bg on" : "")" @onclick=startGame>start</button>
            <button type="button" class="soft-shadow game-button" @onclick=resetGame>reset</button>
        </div>
    </div>
    <div id="game-container" class="soft-shadow" tabindex="0" @onkeydown=@((e) => playerInputHandler(e.Key))>
        <GameCanvas @ref=gameScreen appID=@_myID />
        @if (turnCount > 0 && !gameControl.Enabled)
        {
            <PostGameView currentScore=currentScore highScore=highScore app=AppID.Snake />
        }
    </div>
    @if (isMobile)
    {
        <TouchDPad clickCallback=playerInputHandler />
    }
</main>

@code {
    private GameCanvas? gameScreen;
    private bool isMobile = false;

    private int turnCount { get; set; }
    private bool canMove { get; set; }

    public SnakeGame() : base(AppID.Snake)
    {
        gameControl.Interval = 400;
    }    

    protected override async Task OnInitializedAsync()
    {
        isMobile = await jsRuntime.InvokeAsync<bool>("isMobile");
        highScore = await scoreService.readLocalScore(_myID);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await resetGame();
            canvasRefresh.Elapsed += drawGame;
            gameControl.Elapsed += runGame;
        }
    }

    private void increaseSpeed(Object? sender, EventArgs e)
    {
        if (gameControl.Enabled)
        {
            gameControl.Interval = 1300 / game!.player.healthPoints;
            if (isMobile) jsRuntime.InvokeVoidAsync("vibrateFeedback");
        }
    }

    private void playerInputHandler(string direction)
    {
        if (gameControl.Enabled && canMove)
        {
            game!.player.parseMoveCommand(direction);
        }
        canMove = false;
    }

    protected async override Task stopGame()
    {
        toggleControlObjects();
    }

    protected async override Task startGame()
    {
        await jsRuntime.InvokeVoidAsync("setFocus");
        if (gameControl.Enabled)
            return;
        else
        {
            if (currentScore.scoreValue > 0)
            {
                currentScore = new Score(_myID);
                await resetGame();
            }
            toggleControlObjects();
            currentScore.runStart = DateTime.Now;
        }
    }

    protected async override Task resetGame()
    {
        turnCount = 0;
        gameControl.Interval = 400;
        if (gameControl.Enabled)
            toggleControlObjects();
        await gameScreen.setCanvasSize();
        await gameScreen.clear();
        game = new SnakeBoard(
            gameScreen.getDimensions(),
            gameScreen.baseResolution,
            gameScreen.canvasReference);
        game.ateFood += increaseSpeed;
    }

    protected override void runGame(Object? src, ElapsedEventArgs e)
    {
        turnCount++;
        currentScore.runLength = e.SignalTime - currentScore.runStart;
        currentScore.scoreValue += (long)Math.Ceiling(turnCount / 10.0) * game!.player.healthPoints;
        if (game.checkSnakeParts() is false)
        {
            toggleControlObjects();
            if (currentScore.scoreValue > highScore.scoreValue)
            {
                highScore = currentScore;
                scoreService.setLocalScore(highScore);
            }
        }
        else
            game.updateGameState();

        canMove = true;
        StateHasChanged();
    }

    protected async override void drawGame(Object? o, ElapsedEventArgs e)
    {
        await gameScreen.canvasReference.BeginBatchAsync();

        await gameScreen.fillColor("white");
        await game!.renderGameState();
        // TODO - Figure out how to scale fixed assets and refactor
        await gameScreen.canvasReference.EndBatchAsync();
    }


    public override void DisposeHarder()
    {
        gameScreen.Dispose();
    }
}
