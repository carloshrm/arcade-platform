@page "/invaders"
@inject IJSRuntime jsRuntime
@inject IScoreService scoreService

<main id="main-content">
    <div id="game-controls">
        <div id="score-display">
            <span> Score:@currentScore?.scoreValue </span>
            @if (highScore?.scoreValue > 0)
            {
                <span> Best: @highScore?.scoreValue  </span>
            }
            <span> Round:@currentScore?.turn </span>
        </div>
        <div>
            <button type="button" class="soft-shadow game-button" @onclick=startGame>start</button>
            <button type="button" class="soft-shadow game-button" @onclick=resetGame>reset</button>
        </div>
    </div>
    <div id="game-container" tabindex="0" @onkeydown=keyDownInputHandler @onkeyup=keyUpInputHandler>
        <ResponsiveCanvas @ref=gameScreen appID=AppID.Invaders />
    </div>
</main>

@foreach (var s in ShipModel.availableModels)
{
    <img hidden src=@($"/img/invaderAssets/{s.spriteId}.png") @ref=@(assets[s.spriteId]) />
}
<img hidden src=@($"/img/invaderAssets/splash.png") @ref=@(assets[-1]) />
<img hidden src=@($"/img/invaderAssets/laser.png") @ref=@(assets[-2]) />

@code {
    private ResponsiveCanvas? gameScreen;
    private (int row, int col) limits;
    private double scale;
    private Score currentScore;
    private Score highScore;

    private Timer mainGameControl;
    private Timer invaderControl;

    private Space space;
    private Dictionary<int, ElementReference> assets;

    public InvadersGame()
    {
        invaderControl = new Timer(800) { AutoReset = true, Enabled = false };
        invaderControl.Elapsed += updateInvaderState;
        mainGameControl = new Timer(15) { AutoReset = true, Enabled = false };
        mainGameControl.Elapsed += updateGameState;
        currentScore = new Score(AppID.Invaders);
        highScore = currentScore;
        assets = new Dictionary<int, ElementReference>();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (gameScreen != null)
            {
                await gameScreen.setCanvasSize();
                limits = gameScreen.getDimensions();
                space = new Space(limits);
                setScale();
            }
            StateHasChanged();
            highScore = await scoreService.readLocalScore(AppID.Snake);
        }
    }

    private void setScale()
    {
        (int w, int h) = gameScreen.getScreenSize();
        if (w > 1000 || h > 1000) 
            scale = 1.2;
        else if (w < 600 || h < 600) 
            scale = 0.8;
    }

    public void startGame()
    {
        jsRuntime.InvokeVoidAsync("setFocus");
        if (mainGameControl.Enabled)
            return;
        else
        {
            toggleControlObjects();
        }
    }

    public void toggleControlObjects()
    {
        mainGameControl.Enabled = !mainGameControl.Enabled;
        invaderControl.Enabled = !invaderControl.Enabled;
    }

    private void resetGame()
    {
        if (mainGameControl.Enabled)
            toggleControlObjects();
        currentScore = new Score(AppID.Invaders);
        space = new Space(limits);
        gameScreen.clear();
    }

    private void keyDownInputHandler(KeyboardEventArgs e)
    {
        space.parseKeyDown(e.Key, e.Repeat);
    }

    private void keyUpInputHandler(KeyboardEventArgs e)
    {
        space.parseKeyUp(e.Key);
    }

    public async void updateGameState(Object? o, ElapsedEventArgs e)
    {
        space.hitDetection();
        space.player.updatePosition(limits.row, limits.col);
        space.updateSpecialInvader(limits);
        foreach (var s in space.shotsFired)
        {
            s.updatePosition(limits.row, limits.col);
        }
        drawGameState();
    }

    private async void updateInvaderState(Object? o, EventArgs e)
    {
        space.shotCleanup(limits);

        bool touchedEdge = false;
        space.invaders.ForEach(i => { 
            if (i.updatePosition(limits.row, limits.col)) touchedEdge = true;
            i.model.spriteSelect = i.model.spriteSelect == 1 ? 0 : 1;
        });
        if (touchedEdge) 
        {
            InvaderShip.flipDirection();
            space.invaders.ForEach(i =>
                {
                    i.dropRow(limits.row);
                    i.updatePosition(limits.row, limits.col);
                });
        }

        space.invaders.RemoveAll(i => { 
            if (i.healthPoints <= 0)
            {
                currentScore.scoreValue += Space.baseScore * i.model.spriteId;
                return true;
            }
            else
                return false;
        });
        if (space.specialInvader.healthPoints <= 0) space.specialInvader = null;
        space.invaderAttack();
        space.invaderStepCount++;
        // TODO - speed up 
        // TODO - refactor cleanups into methods using GameObject
    }

    private async Task drawObject(GameObject a)
    {
        await gameScreen.canvasReference.DrawImageAsync(
            assets[a.model.spriteId], // asset IMG reference
            a.model.spriteSelect * a.model.width, 0 * a.model.height, // asset position in reference png
            a.model.width, a.model.height, // asset size in png
            a.col, a.row, // canvas coords for rendering
            a.model.width * scale, a.model.height * scale); // size for rendering in canvas
    }

    private async Task drawSet(IEnumerable<GameObject> list)
    {
        foreach (var o in list)
        {
            await drawObject(o);
        }
    }

    private async void drawGameState()
    {
        await gameScreen.clear();
        await gameScreen.canvasReference.BeginBatchAsync();
        await drawSet(space.invaders);
        await drawSet(space.shotsFired);
        await drawObject(space.player);
        if (space.specialInvader != null) await drawObject(space.specialInvader);
        await gameScreen.canvasReference.EndBatchAsync();
    }
}
