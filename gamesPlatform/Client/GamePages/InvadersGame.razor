@page "/invaders"
@inject IJSRuntime jsRuntime
@inject IScoreService scoreService
@implements IDisposable
@using cmArcade.Shared.Invaders

<main id="main-content">
    <div id="game-controls">
            <button type="button" class="soft-shadow game-button" @onclick=startGame>start</button>
            <button type="button" class="soft-shadow game-button" @onclick=resetGame>reset</button>
    </div>
    <div id="game-container" tabindex="0" @onkeydown=keyDownInputHandler @onkeyup=keyUpInputHandler>
        <ResponsiveCanvas @ref=gameScreen appID=AppID.Invaders />
        @if (currentScore?.turn > 0 && gameOver)
        {
            <div id="post-game-container" class="dark-bg soft-shadow">
                <h2>Game Over...</h2>
                <h4>Score: @currentScore?.scoreValue</h4>
                <h4>Best: @highScore?.scoreValue</h4>
                @if (canUpload)
                {
                    <button type="button" @onclick=@(() => showScoreUpload = true )>Pin on leaderboard!</button>
                }
                <LeaderboardView appID=AppID.Invaders @ref=leaderboard />
            </div>
            @if (showScoreUpload && canUpload)
            {
                <ScoreUpload info=@highScore callback=@uploadCallback />
            }
        }
    </div>
</main>

@foreach (var a in new List<GameAsset>().Concat(ShipModel.invaderShips).Concat(GameDecal.decals))
{
    <img hidden src =@($"/img/invaderAssets/{a.spriteId}.png") @ref=assets[a.spriteId] />
}
<img hidden src=@($"/img/invaderAssets/player.png") @ref=@(assets[ShipModel.playerShip.spriteId]) />

@code {
    private ResponsiveCanvas? gameScreen;
    private double scale;
    private Score currentScore;
    private Score highScore;
    private bool combo = false;

    private Timer spaceControl;
    private Timer invaderControl;
    private Timer canvasRefresh;

    private Space space;
    private Dictionary<string, ElementReference> assets;

    // TODO - refactor into post game component
    // TODO - refactor score into service
    private bool gameOver = false;
    private bool canUpload = false;
    private bool showScoreUpload = false;
    private LeaderboardView? leaderboard;
    private Action<int> uploadCallback;

    public InvadersGame()
    {
        invaderControl = new Timer(800) { AutoReset = true, Enabled = false };
        spaceControl = new Timer(15) { AutoReset = true, Enabled = false };
        canvasRefresh = new Timer(1000/60) { AutoReset = true, Enabled = false };
        currentScore = new Score(AppID.Invaders);
        highScore = currentScore;
        scale = 1;
        assets = new Dictionary<string, ElementReference>();
        uploadCallback = new Action<int>(refreshAfterUpload);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (gameScreen != null)
            {
                await gameScreen.setCanvasSize();
                await gameScreen.canvasReference.SetFontAsync("16px \"Press Start 2P\"");
                await gameScreen.canvasReference.SetFillStyleAsync("White");
                space = new Space(gameScreen.getDimensions());
                setScale();
            }
            highScore = await scoreService.readLocalScore(AppID.Invaders);
            canUpload = highScore.id == -1;
            space.gameOver += stopGame;
            invaderControl.Elapsed += invaderStep;
            spaceControl.Elapsed += space.updateGameState;
            canvasRefresh.Elapsed += drawGame;
            StateHasChanged();
        }
    }

    private void setScale()
    {
        (int w, int h) = gameScreen.getScreenSize();
        if (w > 1000 || h > 1000) 
            scale = 1.2;
        else if (w < 600 || h < 600) 
            scale = 0.8;
    }

    private void refreshAfterUpload(int newID)
    {
        showScoreUpload = false;
        if (newID != -1)
        {
            canUpload = false;
            highScore.id = newID;
            leaderboard.refresh();
        }
        StateHasChanged();
    }

    private void startGame()
    {
        jsRuntime.InvokeVoidAsync("setFocus");
        if (spaceControl.Enabled)
            return;
        else
        {
            if (currentScore.scoreValue > 0)
                resetGame();
            currentScore.turn = 1;
            currentScore.runStart = DateTime.Now;
            toggleControlObjects();
        }
    }

    private void toggleControlObjects()
    {
        spaceControl.Enabled = !spaceControl.Enabled;
        invaderControl.Enabled = !invaderControl.Enabled;
        canvasRefresh.Enabled = !canvasRefresh.Enabled;
    }

    private async Task nextRound()
    {
        toggleControlObjects();
        for (int i = 3; i != 0; i--)
        {
            await gameScreen?.clear();
            await gameScreen.canvasReference.FillTextAsync($"Next round in {i}...", 50, 50);
            await Task.Delay(1000);
        }
        space = new Space(gameScreen.getDimensions());
        currentScore.turn++;
        toggleControlObjects();
    }

    private void resetGame()
    {
        if (spaceControl.Enabled) toggleControlObjects();
        currentScore = new Score(AppID.Invaders);
        space = new Space(gameScreen.getDimensions());
        gameOver = false;
        gameScreen.clear();
    }

    private void keyDownInputHandler(KeyboardEventArgs e)
    {
        space.parseKeyDown(e.Key);
    }

    private void keyUpInputHandler(KeyboardEventArgs e)
    {
        space.parseKeyUp(e.Key);
    }

    private void stopGame(Object? o, EventArgs e)
    {
        gameOver = true;
        toggleControlObjects();
        currentScore.runLength = currentScore.runStart - DateTime.Now;
        if (currentScore.scoreValue > highScore.scoreValue)
        {
            highScore = currentScore;
            scoreService.setLocalScore(highScore);
            canUpload = true;
        }
        StateHasChanged();
    }

    private void invaderStep(Object? o, EventArgs e)
    {
        if (space.invaders.Count == 0) nextRound();
        space.updateSpaceState();
        var stepScore = space.invaderCleanup();
        currentScore.scoreValue += currentScore.turn * stepScore * (combo ? 2 : 1);
        combo = stepScore != 0;
        space.invaderAttack();
        invaderControl.Interval = space.invaders.Count / 0.05;
        space.sendSpecial();
    }

    private async Task drawObject(GameObject obj)
    {
        await gameScreen.canvasReference.DrawImageAsync(
            assets[obj.model.spriteId], // asset IMG reference
            obj.spriteSelect * obj.model.width, 0 * obj.model.height, // asset position in reference png
            obj.model.width, obj.model.height, // asset size in png
            obj.col, obj.row, // canvas coords for rendering
            obj.model.width * scale, obj.model.height * scale); // size for rendering in canvas
    }

    private async Task drawSet(IEnumerable<GameObject> list)
    {
        foreach (var o in list) { await drawObject(o); }
    }

    private async Task drawUI()
    {
        await gameScreen.canvasReference.FillTextAsync(getUIText(), 10, 20);
        for (int i = 1; i <= space.player.healthPoints; i++)
        {
            await gameScreen.canvasReference.DrawImageAsync(assets["heart"], gameScreen.componentWidth - (30 * i), 5);
        }
    }

    private string getUIText()
    {
        var text = new StringBuilder();
        text.Append($"Score:{currentScore.scoreValue}\t");
        if (highScore.scoreValue > 0) text.Append($"Best:{highScore.scoreValue}\t");
        text.Append($"Level:{currentScore.turn}");
        return text.ToString();
    }

    private async void drawGame(Object? o, ElapsedEventArgs e)
    {
        await gameScreen.clear();
        await gameScreen.canvasReference.BeginBatchAsync();
        await drawUI();
        await drawSet(space.invaders);
        await drawSet(space.shotsFired);
        await drawSet(space.barriers);
        await drawObject(space.player);
        if (space.specialInvader != null) await drawObject(space.specialInvader);
        await gameScreen.canvasReference.EndBatchAsync();
    }

    public void Dispose()
    {
        gameScreen?.Dispose();
        invaderControl.Dispose();
        spaceControl.Dispose();
    }
}
