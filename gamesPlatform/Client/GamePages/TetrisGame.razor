@page "/tetris"
@inject IJSRuntime jsRuntime
@inject IScoreService scoreService
@implements IDisposable
@inherits GamePage<TetrisField>
@using cmArcade.Shared
@using cmArcade.Shared.Tetris

<main id="main-content" @onkeydown:preventDefault="true">
    <div id="game-controls">
        <button type="button" class="soft-shadow game-button @((currentScore.scoreValue > 0 && gameControl.Enabled) ? "dark-bg ok" : "")" @onclick=startGame>start</button>
        <button type="button" class="soft-shadow game-button" @onclick=resetGame>reset</button>
    </div>
    <div id="game-container" tabindex="0" @onkeydown=@((e) => keyDownInputHandler(e.Key)) @onkeyup=@((e) => keyUpInputHandler(e.Key))>
        <GameCanvas @ref=gameScreen appID=_myID />
        @if (currentScore?.turn > 0 && gameOver)
        {
            <PostGameView currentScore=currentScore highScore=highScore app=_myID />
        }
    </div>
    @if (isMobile)
    {
        <TouchDPad clickCallback=keyDownInputHandler releaseCallback=keyUpInputHandler />
    }
</main>

<img hidden src=@($"/img/tetrisAssets/blocks.png") @ref=@(gameScreen.assets[/* write asset id here */]) />

@code {
    private DateTime? holdStart;
    private TimeSpan timeHeld;

    private GameCanvas? gameScreen;

    private bool gameOver = false;

    private bool isMobile = false;
    private bool mobileMoveToggle = false;

    public TetrisGame() : base(AppID.Tetris)
    {
        ///
    }

    protected override async Task OnInitializedAsync()
    {
        isMobile = await jsRuntime.InvokeAsync<bool>("isMobile");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (gameScreen != null)
            {
                await gameScreen.setCanvasSize();
                await gameScreen.canvasReference.SetFontAsync("16px \"Press Start 2P\"");
                await gameScreen.canvasReference.SetFillStyleAsync("white");
                game = new TetrisField(gameScreen.getDimensions());
            }
            highScore = await scoreService.readLocalScore(_myID);
            gameControl.Elapsed += runGame;
            canvasRefresh.Elapsed += drawGame;
            StateHasChanged();
        }
    }

    protected override void startGame()
    {
        jsRuntime.InvokeVoidAsync("setFocus");
        if (gameControl.Enabled)
            return;
        else
        {
            if (currentScore.scoreValue > 0)
                resetGame();
            currentScore.turn = 1;
            currentScore.runStart = DateTime.Now;
            toggleControlObjects();
        }
    }

    protected override void resetGame()
    {
        jsRuntime.InvokeVoidAsync("setFocus");
        if (gameControl.Enabled) toggleControlObjects();
        currentScore = new Score(_myID);
        game = new TetrisField(gameScreen!.getDimensions());
        gameOver = false;
        gameScreen?.clear();
    }

    protected override void stopGame()
    {
        gameOver = true;
        toggleControlObjects();
        currentScore.runLength = DateTime.Now - currentScore.runStart;
        if (currentScore.scoreValue > highScore.scoreValue)
        {
            highScore = currentScore;
            scoreService.setLocalScore(highScore);
        }
        StateHasChanged();
    }

    private void keyDownInputHandler(string dir)
    {
        game.parseKeyDown(dir);
    }

    private void keyUpInputHandler(string dir)
    {
        game.parseKeyUp(dir);
    }

    private string getUIText()
    {
        // TODO - make up
        return string.Empty;
    }

    private async void runGame(Object? o, ElapsedEventArgs e)
    {
        game.updateGameState(currentScore);
        // TODO - implement run logic
        if (game.checkGameOver()) stopGame();
    }

    private async void drawGame(Object? o, ElapsedEventArgs e)
    {
        await gameScreen.canvasReference.BeginBatchAsync();
        await gameScreen.fillColor("black");
        await gameScreen.canvasReference.FillTextAsync(getUIText(), 10, 20);

        for (int i = 0; i < game.fieldMessages.Count; i++)
            await gameScreen.fillTextStyleOverride(game.fieldMessages[i], 0, (gameScreen.getDimensions().y / 2) + (i * 20), "10px \"Press Start 2P\"", "yellow");

        if (game.ballOnHold)
            await gameScreen.canvasReference.FillTextAsync("hit spacebar or up to release the ball", (gameScreen.getDimensions().x / 5.5), (gameScreen.getDimensions().y * 0.8));

        for (int i = 1; i <= game.player.healthPoints; i++)
            await gameScreen.canvasReference.DrawImageAsync(gameScreen.assets["heart"], gameScreen.componentWidth - (40 * i), 10);

        await gameScreen.drawObject(game.player);
        await gameScreen.drawSet(game.balls);
        await gameScreen.drawSet(game.powerups);
        game.blocks.ForEach(async (r) => await gameScreen.drawSet(r));
        await gameScreen.canvasReference.EndBatchAsync();
    }

    public void Dispose()
    {
        gameScreen?.Dispose();
        gameControl.Dispose();
        canvasRefresh.Dispose();
    }
}
