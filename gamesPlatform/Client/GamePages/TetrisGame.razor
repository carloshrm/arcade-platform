@page "/tetris"
@inject IJSRuntime jsRuntime
@inject IScoreService scoreService
@implements IDisposable
@inherits GamePage<TetrisField>
@using cmArcade.Shared
@using cmArcade.Shared.Tetris

<main id="main-content" @onkeydown:preventDefault=@(!gameOver)>
    <div id="game-controls">
        <button type="button" class="soft-shadow game-button @((currentScore.scoreValue > 0 && gameControl.Enabled) ? "dark-bg ok" : "")" @onclick=StartGame>start</button>
        <button type="button" class="soft-shadow game-button" @onclick=ResetGame>reset</button>
    </div>
    <div id="game-container" tabindex="0" @onkeydown=@((e) => KeyDownHandler(e.Key)) @onkeyup=@((e) => KeyUpHandler(e.Key))>
        <GameCanvas @ref=gameScreen appID=_myID />
        @if (currentScore?.turn > 0 && !gameControl.Enabled)
        {
            <PostGameView currentScore=currentScore highScore=highScore appID=_myID />
        }
    </div>
    @if (isMobile)
    {
        <TouchDPad clickCallback=KeyDownHandler releaseCallback=KeyUpHandler />
    }
</main>

@foreach (var id in assetList)
{
    <GameImageAsset assetID=@id appID=@_myID />
}

@code {
    private GameCanvas? gameScreen;

    private bool gameOver = false;

    private bool isMobile = false;
    private bool mobileMoveToggle = false;

    public TetrisGame() : base(AppID.Tetris)
    {
        assetList.Add(TetrisPlayerModel.player.spriteId);
    }

    protected override async Task OnInitializedAsync()
    {
        isMobile = await jsRuntime.InvokeAsync<bool>("isMobile");
        if (isMobile)
            textStyle = ("8px \"Press Start 2P\"", "white");
        highScore = await scoreService.readLocalScore(_myID);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (gameScreen != null)
            {
                await gameScreen.SetCanvasSize();
                game = new TetrisField(gameScreen.baseResolution);
                gameScreen.SetupImageAsset(assetList);
            }
            gameControl.Interval = 1000;
            gameControl.Elapsed += RunGame;
            canvasRefresh.Elapsed += DrawGame;
            StateHasChanged();
        }
    }

    protected async override Task StartGame()
    {
        await jsRuntime.InvokeVoidAsync("setFocus");
        if (gameControl.Enabled)
            return;
        else
        {
            if (currentScore.scoreValue > 0)
                await ResetGame();
            currentScore.turn = 1;
            currentScore.runStart = DateTime.Now;
            ToggleControlObjects();
        }
    }

    protected async override Task ResetGame()
    {
        await jsRuntime.InvokeVoidAsync("setFocus");
        if (gameControl.Enabled)
            ToggleControlObjects();
        gameControl.Interval = 1000;
        currentScore = new Score(_myID);
        game = new TetrisField(gameScreen.baseResolution);
        gameOver = false;
        gameScreen?.ClearCanvas();
    }

    protected override async Task StopGame()
    {
        gameOver = true;
        ToggleControlObjects();
        currentScore.runLength = DateTime.Now - currentScore.runStart;
        if (currentScore.scoreValue > highScore.scoreValue)
        {
            highScore = currentScore;
            await scoreService.setLocalScore(highScore);
        }
        StateHasChanged();
    }

    protected override void KeyDownHandler(string key)
    {
        game.parseKeyDown(key);
    }

    protected override void KeyUpHandler(string key)
    {
        game.parseKeyUp(key);
    }

    private string getUIText()
    {
        return
            $"Time: \n  {currentScore.runLength.ToString("mm\\:ss")}\n" +
            $"Score:\n{currentScore.scoreValue}" +
            $"{game.scoreMult} lines\n" +
            $"Best: \n  {highScore.scoreValue}\n \n" +
            ":: Controls ::\nA D/Arrows:\n  Move\nUp:\n  Rotate \nSpacebar:\n  Drop";
    }

    protected async override void RunGame(Object? o, ElapsedEventArgs e)
    {
        currentScore.turn += 1;
        game.UpdateGameState(currentScore);
        if (game.CheckGameOver())
            await StopGame();

        gameControl.Interval = 1000 - ((game.scoreMult + 1) * 20);
    }

    protected async override void DrawGame(Object? o, ElapsedEventArgs e)
    {
        gameScreen.FillCanvas("black");
        gameScreen.DrawSimpleImage(TetrisPlayerModel.player.spriteId, 0, 0, gameScreen.componentWidth, gameScreen.componentHeight);
        gameScreen.FillTextExtended(getUIText(), gameScreen.componentWidth * 0.02, 20, textStyle, 10);

        game.active.parts.ForEach(p => gameScreen.DrawScaledObject(p));

        for (int i = 0; i < game.field.Length; i++)
        {
            for (int j = 0; j < game.field[i].Length; j++)
            {
                if (game.field[i][j] != null)
                    gameScreen.DrawScaledObject(game.field[i][j]);
            }
        }

        gameScreen.FillTextExtended("Next: ", gameScreen.componentWidth * 0.84, 20, textStyle, 10);
        game.next.Peek().parts.ForEach(pt => gameScreen.DrawScaledObject(pt));
        await gameScreen.RenderQueue();
    }

    public override void DisposeHarder()
    {
        gameScreen?.Dispose();
    }
}
