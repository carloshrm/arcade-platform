@inject IConfiguration appConfig
@inject IJSRuntime jsRuntime
@using Excubo.Blazor.Canvas
@using Excubo.Blazor.Canvas.Contexts
@implements IDisposable

<Canvas @ref="displayCanvas" width="@componentWidth" height="@componentHeight" />

@code {
    [Parameter] public AppID appID { get; set; }

    private Canvas displayCanvas { get; set; }
    private Context2D displayContext { get; set; }
    private Context2D? _renderContext;

    private Queue<Action<Batch2D>> _renderQueue = new();

    public int componentWidth { get; set; }
    public int componentHeight { get; set; }
    public long windowWidth { get; set; }
    public long windowHeight { get; set; }
    public (int r, int c) baseResolution { get; set; }
    public (int r, int c) scaleFactor { get; set; } = (1, 1);

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            displayContext = await displayCanvas.GetContext2DAsync();
            if (_renderContext == null)
            {
                await jsRuntime.InvokeVoidAsync("eval", $"window.{nameof(_renderContext)} = new OffscreenCanvas({componentWidth}, {componentHeight})");
                _renderContext = await CanvasHelper.GetContext2DAsync(jsRuntime, $"window.{nameof(_renderContext)}");
            }
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await ReadConfigurationValues();
    }

    private async Task ReadConfigurationValues()
    {
        foreach (var setting in appConfig.GetSection("games").GetChildren())
        {
            if (setting.GetValue<AppID>("id") == appID)
            {
                baseResolution = (
                    setting.GetValue<int>("size:width"),
                    setting.GetValue<int>("size:height"));
                return;
            }
        }        
    }

    public async void SetupImageAsset(IEnumerable<string> assets)
    {
        foreach (var assetID in assets)
            SetupImageAsset(assetID);
    }

    public async void SetupImageAsset(string assetID)
    {
        await jsRuntime.InvokeVoidAsync("eval", $"{assetID} = document.getElementById('im-{assetID}')");
    }

    public async Task SetCanvasSize()
    {
        windowWidth = await jsRuntime.InvokeAsync<long>("getWindowWidth");
        windowHeight = await jsRuntime.InvokeAsync<long>("getWindowHeight");

        int screenLimit = Math.Min((int)(windowWidth * 0.08) * 10, (int)(windowHeight * 0.08) * 10);
        (componentWidth, componentHeight) = appID switch
        {
            AppID.Snake => 
                (screenLimit - (screenLimit % baseResolution.c), screenLimit - (screenLimit % baseResolution.r)),
            AppID.Tetris =>
                (screenLimit - (screenLimit % baseResolution.c), screenLimit - (screenLimit % baseResolution.r)),
            _ => baseResolution            
        };
        StateHasChanged();
        SetupScaleFactor();
    }

    public async Task RenderQueue()
    {
        await using (var batch = _renderContext.CreateBatch())
        {
            while (_renderQueue.TryDequeue(out Action<Batch2D>? renderStep))
                renderStep.Invoke(batch);

            await displayContext.DrawImageAsync($"window.{nameof(_renderContext)}", 0, 0);
        }
    }

    public void DrawScaledRectColored(float c, float r, string color)
    {
        _renderQueue.Enqueue(async (Batch2D targetContext) => 
        {
            await targetContext.FillStyleAsync(color);
            await targetContext.FillRectAsync(c * scaleFactor.c, r * scaleFactor.r, scaleFactor.c, scaleFactor.r);
        });
    }

    public void DrawScaledRect(float c, float r)
    {
        _renderQueue.Enqueue(async (Batch2D targetContext) => await targetContext.FillRectAsync(c * scaleFactor.c, r * scaleFactor.r, scaleFactor.c, scaleFactor.r));
    }

    public void DrawScaledObject(ISimpleGameObject obj)
    {
        _renderQueue.Enqueue(async (Batch2D targetContext) =>
        {
            await targetContext.FillStyleAsync(obj.model.color);
            await targetContext.FillRectAsync(obj.pos.X * scaleFactor.c, obj.pos.Y * scaleFactor.r, scaleFactor.c, scaleFactor.r);
        });
    }

    public void DrawSimpleImage(string assetID, double x, double y)
    {
        _renderQueue.Enqueue(async (Batch2D targetContext) =>
        {
            await targetContext.DrawImageAsync(assetID, x, y);
        });
    }

    public void DrawSimpleImage(string assetID, double x, double y, double w, double h)
    {
        _renderQueue.Enqueue(async (Batch2D targetContext) =>
        {
            await targetContext.DrawImageAsync(assetID, x, y, w, h);
        });
    }

    public void DrawObject(IGameObject obj)
    {
        // renders from the top left
        _renderQueue.Enqueue(async (Batch2D targetContext) =>
        {
            await targetContext.DrawImageAsync(
                obj.model.spriteId, // asset image reference
                obj.spriteSelect * obj.model.width, obj.model.height * 0, // asset position on referenced image
                obj.model.width, obj.model.height, // asset size on image
                obj.pos.X, obj.pos.Y, // canvas x and y coords for rendering
                obj.model.width, obj.model.height); // size for rendering in canvas
            if (obj.decals != null)
            {
                foreach (var d in obj.decals)
                {
                    int widthPadding = d.width < obj.model.width ? (d.width / -2) + ((obj.model.width) / 2) : 0;
                    int heightPadding = d.height < obj.model.height ? (d.height / -2) + ((obj.model.height) / 2) : 0;
                    await targetContext.DrawImageAsync(
                        d.spriteId, 0, 0, d.width, d.height,
                        obj.pos.X + widthPadding, obj.pos.Y + heightPadding,
                        d.width, d.height);
                }
            }
        });
    }

    public void DrawObject(IDrawable obj, Vector2 pos)
    {
        // renders from the top left
        _renderQueue.Enqueue(async (Batch2D targetContext) =>
        {
            await targetContext.DrawImageAsync(
                obj.model.spriteId, // asset image reference
                obj.spriteSelect * obj.model.width, obj.model.height * 0, // asset position on referenced image
                obj.model.width, obj.model.height, // asset size on image
                pos.X, pos.Y, // canvas x and y coords for rendering
                obj.model.width, obj.model.height); // size for rendering in canvas
            if (obj.decals != null)
            {
                foreach (var d in obj.decals)
                {
                    int widthPadding = d.width < obj.model.width ? (d.width / -2) + ((obj.model.width) / 2) : 0;
                    int heightPadding = d.height < obj.model.height ? (d.height / -2) + ((obj.model.height) / 2) : 0;
                    await targetContext.DrawImageAsync(
                        d.spriteId, 0, 0, d.width, d.height,
                        pos.X + widthPadding, pos.Y + heightPadding,
                        d.width, d.height);
                }
            }
        });
    }

    public void DrawVectorialObject(ISimpleVectorialObject obj)
    {
        _renderQueue.Enqueue(async (Batch2D targetContext) =>
        {
            await targetContext.BeginPathAsync();

            bool first = true;
            foreach (var pt in obj.model.points)
            {
                if (first)
                {
                    await targetContext.MoveToAsync(pt.X + obj.pos.X, pt.Y + obj.pos.Y);
                    first = false;
                }
                await targetContext.LineToAsync(pt.X + obj.pos.X, pt.Y + obj.pos.Y);
            }
            await targetContext.ClosePathAsync();

            await targetContext.StrokeStyleAsync(obj.model.strokeColor);
            await targetContext.StrokeAsync();

            if (obj.model.fillColor != null)
            {
                await targetContext.FillStyleAsync(obj.model.fillColor);
                await targetContext.FillAsync(FillRule.NonZero);
            }            

        });
    }

    public void DrawVectorialSet(IEnumerable<ISimpleVectorialObject> list)
    {
        foreach (var obj in list)
            DrawVectorialObject(obj);
    }

    public void DrawObjectSet(IEnumerable<IGameObject> list)
    {
        foreach (var o in list)
            DrawObject(o);
    }

    public void ClearCanvas()
    {
        _renderQueue.Enqueue(async (Batch2D targetContext) =>
        {
            await targetContext.ClearRectAsync(0, 0, componentWidth, componentHeight);
        });
    }

    public void FillCanvas(string color)
    {
        _renderQueue.Enqueue(async (Batch2D targetContext) =>
        {
            await targetContext.FillStyleAsync(color);
            await targetContext.FillRectAsync(0, 0, componentWidth, componentHeight);
        });
    }

    public void FillText(string text, double x, double y)
    {
        _renderQueue.Enqueue(async (Batch2D targetContext) =>
        {
            await targetContext.FillTextAsync(text, x, y);
        });
    }

    public void FillTextExtended(string text, double x, double y, (string font, string color) style, int linePadding = 0)
    => FillTextExtended(text, x, y, style.font, style.color, linePadding);

    public void FillTextExtended(string text, double x, double y, string font, string style, int linePadding = 0)
    {
        _renderQueue.Enqueue(async (Batch2D targetContext) =>
        {
            await targetContext.FontAsync(font);
            await targetContext.FillStyleAsync(style);

            var lines = text.Split('\n');
            int yOffset = int.Parse(font.Substring(0, font.IndexOf("px"))) + linePadding;
            for (int i = 0; i < lines.Length; i++)
            {
                await targetContext.FillTextAsync(lines[i], x, y + (yOffset * i));
            }
        });
    }

    public void SetupScaleFactor()
    {
        scaleFactor = (componentHeight / baseResolution.r, componentWidth / baseResolution.c);
        if (scaleFactor.c == 0 || scaleFactor.r == 0)
            scaleFactor = (1, 1);
    }

    public (int y, int x) GetDimensions()
    {
        return (y: componentHeight, x: componentWidth);
    }

    public (int, int) GetScreenSize()
    {
        return ((int)windowWidth, (int)windowHeight);
    }

    public void Dispose()
    {
        displayContext.DisposeAsync();
    }
}
