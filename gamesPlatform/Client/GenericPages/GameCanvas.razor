@inject IConfiguration appConfig
@inject IJSRuntime jsRuntime
@using Blazor.Extensions
@using Blazor.Extensions.Canvas.Canvas2D
@implements IDisposable

<BECanvas Width="@componentWidth" Height="@componentHeight" @ref="_componentReference" />

@code {
    [Parameter] public AppID appID { get; set; }

    private BECanvasComponent? _componentReference { get; set; }
    public Canvas2DContext? canvasReference { get; set; }
    public Dictionary<string, ElementReference> assets;

    public GameCanvas()
    {
        assets = new Dictionary<string, ElementReference>();
    }

    public int componentWidth { get; set; }
    public int componentHeight { get; set; }
    public long windowWidth { get; set; }
    public long windowHeight { get; set; }
    public (int r, int c) baseResolution { get; set; }
    public (int r, int c) scaleFactor { get; set; } = (1, 1);


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            canvasReference = await _componentReference.CreateCanvas2DAsync();
        }
    }

    protected override async Task OnInitializedAsync()
    {
        await readConfigValues();
    }

    private async Task readConfigValues()
    {
        foreach (var setting in appConfig.GetSection("games").GetChildren())
        {
            if (setting.GetValue<AppID>("id") == appID)
            {
                baseResolution = (
                    setting.GetValue<int>("size:width"),
                    setting.GetValue<int>("size:height"));
                return;
            }
        }        
    }

    public async Task setCanvasSize()
    {
        windowWidth = await jsRuntime.InvokeAsync<long>("getWindowWidth");
        windowHeight = await jsRuntime.InvokeAsync<long>("getWindowHeight");

        int screenLimit = Math.Min((int)(windowWidth * 0.08) * 10, (int)(windowHeight * 0.08) * 10);
        (componentWidth, componentHeight) = appID switch
        {
            AppID.Snake => 
                (screenLimit - (screenLimit % baseResolution.c), screenLimit - (screenLimit % baseResolution.r)),
            AppID.Tetris =>
                (screenLimit - (screenLimit % baseResolution.c), screenLimit - (screenLimit % baseResolution.r)),
            _ => baseResolution            
        };
        StateHasChanged();
        setupScaleFactor();
    }

    public async Task drawScaledColored(float c, float r, string color)
    {
        await canvasReference.SetFillStyleAsync(color);
        await canvasReference.FillRectAsync(c * scaleFactor.c, r * scaleFactor.r, scaleFactor.c, scaleFactor.r);
    }

    public async Task drawScaled(float c, float r)
    {
        await canvasReference.FillRectAsync(c * scaleFactor.c, r * scaleFactor.r, scaleFactor.c, scaleFactor.r);
    }

    public async Task drawScaledSimpleObject(ISimpleGameObject obj)
    {
        var previousStyle = canvasReference.FillStyle;
        await canvasReference.SetFillStyleAsync(obj.model.color);
        await canvasReference.FillRectAsync(obj.pos.X * scaleFactor.c, obj.pos.Y * scaleFactor.r, scaleFactor.c, scaleFactor.r);
        await canvasReference.SetFillStyleAsync(previousStyle);
    }

    public async Task drawObject(IGameObject obj)
    {
        // renders from the top left
        await canvasReference.DrawImageAsync(
            assets[obj.model.spriteId], // asset image reference
            obj.spriteSelect * obj.model.width, obj.model.height * 0, // asset position on referenced image
            obj.model.width, obj.model.height, // asset size on image
            obj.pos.X, obj.pos.Y, // canvas x and y coords for rendering
            obj.model.width, obj.model.height); // size for rendering in canvas
        if (obj.decals != null)
        {
            foreach (var d in obj.decals)
            {
                int widthPadding = d.width < obj.model.width ? (d.width / -2) + ((obj.model.width) / 2) : 0;
                int heightPadding = d.height < obj.model.height ? (d.height / -2) + ((obj.model.height) / 2) : 0;
                await canvasReference.DrawImageAsync(
                    assets[d.spriteId], 0, 0, d.width, d.height,
                    obj.pos.X + widthPadding, obj.pos.Y + heightPadding,
                    d.width, d.height);
            }
        }
    }

    public async Task drawObject(IDrawable obj, Vector2 pos)
    {
        // renders from the top left
        await canvasReference.DrawImageAsync(
            assets[obj.model.spriteId], // asset image reference
            obj.spriteSelect * obj.model.width, obj.model.height * 0, // asset position on referenced image
            obj.model.width, obj.model.height, // asset size on image
            pos.X, pos.Y, // canvas x and y coords for rendering
            obj.model.width, obj.model.height); // size for rendering in canvas
        if (obj.decals != null)
        {
            foreach (var d in obj.decals)
            {
                int widthPadding = d.width < obj.model.width ? (d.width / -2) + ((obj.model.width) / 2) : 0;
                int heightPadding = d.height < obj.model.height ? (d.height / -2) + ((obj.model.height) / 2) : 0;
                await canvasReference.DrawImageAsync(
                    assets[d.spriteId], 0, 0, d.width, d.height,
                    pos.X + widthPadding, pos.Y + heightPadding,
                    d.width, d.height);
            }
        }
    }

    public async Task drawVectorial(ISimpleVectorialObject obj, bool isStroke = false)
    {
        await canvasReference.BeginPathAsync();
        await canvasReference.SetLineWidthAsync(obj.model.lnWidth);

        if (isStroke)
            await canvasReference.SetStrokeStyleAsync(obj.model.lnColor);
        else
            await canvasReference.SetFillStyleAsync(obj.model.lnColor);

        bool first = true;
        foreach (var pt in obj.model.points)
        {
            if (first)
            {
                await canvasReference.MoveToAsync(pt.X + obj.pos.X, pt.Y + obj.pos.Y);
                first = false;
            }
            await canvasReference.LineToAsync(pt.X + obj.pos.X, pt.Y + obj.pos.Y);
        }
        await canvasReference.ClosePathAsync();

        if (isStroke)
            await canvasReference.StrokeAsync();
        else
            await canvasReference.FillAsync();
    }

    public async Task drawSet(IEnumerable<IGameObject> list)
    {
        foreach (var o in list)
        {
            await drawObject(o);
        }
    }

    public async Task clear()
    {
        await canvasReference.ClearRectAsync(0, 0, _componentReference.Width, _componentReference.Height);
    }

    public async Task fillColor(string color)
    {
        var previousStyle = canvasReference.FillStyle;
        await canvasReference.SetFillStyleAsync(color);
        await canvasReference.FillRectAsync(0, 0, _componentReference.Width, _componentReference.Height);
        await canvasReference.SetFillStyleAsync(previousStyle);
    }

    public async Task fillTextExtended(string text, double x, double y, string font, string style = "", int linePadding = 0)
    {
        var previousStyle = canvasReference.FillStyle;
        var previousFont = canvasReference.Font;

        await canvasReference.SetFontAsync(font);
        await canvasReference.SetFillStyleAsync(style == "" ? previousStyle : style);

        var lines = text.Split('\n');
        int yOffset = int.Parse(font.Substring(0, font.IndexOf("px"))) + linePadding;
        for (int i = 0; i < lines.Length; i++)
        {
            await canvasReference.FillTextAsync(lines[i], x, y + (yOffset * i));
        }

        await canvasReference.SetFillStyleAsync(previousStyle);
        await canvasReference.SetFontAsync(previousFont);
    }

    public void setupScaleFactor()
    {
        scaleFactor = (componentHeight / baseResolution.r, componentWidth / baseResolution.c);
        if (scaleFactor.c == 0 || scaleFactor.r == 0)
            scaleFactor = (1, 1);
    }

    public (int y, int x) getDimensions()
    {
        return (y: componentHeight, x: componentWidth);
    }

    public (int, int) getScreenSize()
    {
        return ((int)windowWidth, (int)windowHeight);
    }

    public void Dispose()
    {
        canvasReference?.Dispose();
    }
}
